---
meta:
  - title: TypeScript 與物件型別
  - name: description
    content: 
  - name: keywords
    content: 
  - name: og:image
    content: https://images.unsplash.com/photo-1582089319119-a788d9f9d976

published: 2023-12-29
---

# {frontmatter.meta[0].title}

這篇文章會聚焦在 TypeScript 型別上，所以不會提到太多 JavaScript 的基本觀念，  
如果不熟悉 JavaScript 的物件 (Object)，可以參考 [MDN - Object][object]。

[object]: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics

## 物件 Object

在 JavaScript 中，物件 (Object) 是一種複合型別 (Compound Type)，  
我們可以透過 `{}` 來直接建立物件，稱為 物件初始化 ([Object Initializer][object_initializer])。

```ts
const position1 = {
   // ^? const position: { x: number; y: number; }
  x: 0,
  y: 0,
};

let position2 = {
  // ^? let position: { x: number; y: number; }
  x: 0,
  y: 0,
};
```

在上面的範例中，我們並沒有明確標註 `position1` 跟 `position2` 的型別，  
透過 TypeScript 推斷出來的型別是 `{ x: number; y: number; }`。

<small>
注意，使用 `let` 或是 `const` 也是會影響到型別資訊。  
在接下來的範例，也會分別提供使用 `let` 跟 `const` 後得到的型別。
</small>

<small>
關於 TypeScript 的型別推斷 (Type Inference) 可以參考 [TypeScript 如何給予型別](./typescript-how-to-type)。
</small>

[object_initializer]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer

### 語法 Syntax

以下示範 物件型別 的型別標註。

```ts
{ x: number; y: number; }
{ x: number; y: number }
{ x: number, y: number, }
{ x: number, y: number }
```

上面可以看到，  
我們標注了一個具有兩個屬性 (properties) 的型別，  
分別是 `x` 跟 `y`，而且都是 `number` 型別。  
我們可以使用 `,` 或是 `;` 來分隔屬性，  
而且最後一個分隔符號可以選擇性忽略。


### Type Annotation

以下示範 物件型別 的型別標註。

```ts
const position1: { x: number; y: number; } = {
   x: 0,
   y: 0,
}

let position2: { x: number; y: number; } = {
  x: 0,
  y: 0,
};
```

同理，我們可以用同樣的方式來標註函式參數 (Function Parameter) 以及 函式回傳值 (Function Return Value)。

```ts
declare function moveTo(position: { x: number; y: number; }): { x: number; y: number; };

moveTo({ x: 0, y: 0 });

const position1 = { x: 0, y: 0 };
moveTo(position1);

let position2 = { x: 0, y: 0 };
moveTo(position2);
```

### Type Alias 與 Interface 的物件型別標註法

當然，我們可以直接針對每個 variable 進行個別物件型別標註，  
但也可以透過 Type Alias 跟 Interface 將型別標註獨立出來，  
讓多個 variable 可以共用同一個型別標註。

以下是 Type Alias 的寫法。

```ts
type Position = { x: number; y: number; };

const position1: Position = {
   x: 0,
   y: 0,
}

let position2: Position = {
   x: 0,
   y: 0,
}

declare function moveTo(position: Position): Position;
```

以下是 Interface 的寫法。

```ts
interface Position {
  x: number;
  y: number;
}

const position1: Position = {
   x: 0,
   y: 0,
}

let position2: Position = {
   x: 0,
   y: 0,
}

declare function moveTo(position: Position): Position;
```

<small>以後有機會我們會再深度探討 Type Alias 與 Interface。</small>

### Property Type

在物件中每個屬性也都有自己的型別，  
TypeScript 會特別在型別資訊上標註 (property) 來表示這是一個屬性。

```ts
const position = {
   x: 0,
// ^? (property) x: number
   y: 0,
// ^? (property) y: number
}
```

## 型別檢查 Type Checks

型別檢查 (Type Checks) 是 TypeScript 重要的功能之一，    
認識它的錯誤訊息 (Error Message) 是了解這套語言的重要一環。

以下會介紹一些常見的物件型別檢查錯誤訊息。

### 重複屬性 Duplicate Property

在 JavaScript 物件初始化時，屬性是可以重複定義的。  
但 TypeScript 會拋出錯誤訊息 `1117`。

```ts
type Position = { x: number; y: number; };

const position: Position = {
  x: 0,
  y: 0,
  x: 0,
//^ An object literal cannot have multiple properties with the same name.(1117)
}
```

以開發的角度來看，這個錯誤訊息是很合理的，  
在物件初始化時，定義屬性重複大多數是開發者的失誤，  
透過這道檢查，可以避免開發者定義無意義的重複屬性，  
以避免誤導後續維護者的可能。

### 多餘屬性 Excess Property Checks

在物件初始化時，開發者定義的屬性超出型別所定義的屬性時，  
TypeScript 會拋出錯誤訊息 `1117`。

```ts
type Position = { x: number; y: number; };

const position1: Position = {
   x: 0,
   y: 0,
   z: 0,
// ^ Object literal may only specify known properties, and 'z' does not exist in type 'Position'.(2353)
}

let position2: Position = {
   x: 0,
   y: 0,
   z: 0,
// ^ Object literal may only specify known properties, and 'z' does not exist in type 'Position'.(2353)
}
```

關於多餘屬性的檢查，以下來討論一個常見的問題。  
請問下面的 `moveTo(position)` 會拋錯嗎？

```ts
interface Position {
  x: number;
  y: number;
}

declare function moveTo(position: Position): Position;

const position = {
  x: 0,
  y: 0,
  z: 0,
};

// error ?
moveTo(position); 
```

這邊提供 [TypeScript Playground](https://tsplay.dev/NB11bw) 讓讀者參考。

同樣的，請問下面的 `moveTo({ x: 0, y: 0, z: 0 })` 會拋錯嗎？

```ts
interface Position {
  x: number;
  y: number;
}

declare function moveTo(position: Position): Position;

// error ?
moveTo({ x: 0, y: 0, z: 0 });
```
這邊也提供 [TypeScript Playground](https://tsplay.dev/mb11bN) 讓讀者參考。

為什麼 `moveTo(position)` 不會拋錯，但 `moveTo({ x: 0, y: 0, z: 0 })` 卻會拋錯呢？

注意到，`moveTo(position)` 跟 `moveTo({ x: 0, y: 0, z: 0 })` 的差異在於，  
`position` 是一個初始化已經結束的 variable，  
`position` 的型別是 `{ x: number; y: number; z: number; }`，  
可以滿足 `Position` 的定義。

而 `{ x: 0, y: 0, z: 0 }` 是正在初始化的物件 value，  
這個 value 



<Exam>
<Exam.Question>
以此類推，請問下面的 `moveTo1` 跟 `moveTo2` 哪一個會拋錯？
```ts
interface Position {
  x: number;
  y: number;
}

function moveTo1(position: Position): Position {
   const result = { x: 0, y: 0, z: 0 };
   return result
}

function moveTo2(position: Position): Position {
   return { x: 0, y: 0, z: 0 }
}
```
</Exam.Question>
<Exam.Answer>
[TypeScript Playground](https://tsplay.dev/mALLXN)
</Exam.Answer>
</Exam>


```ts
interface Config {
  x: number;
  y: number;
  [key: string]: number;
}

declare function defineConfig(config: Config): Config;

defineConfig({ x: 0, y: 0, z: 0 });
```

## Property Modifiers - Optional 

### Syntax

```ts
type Position1 = { x: number; y?: number; };

interface Position {
  x: number;
  y?: number;
}
```

```ts
type Position1 = { x: number; y?: number; };

const position1: Position = {
  x: 0,
}

const position2: Position = {
  x: 0,
  y: 0,
}

const position3: Position = {
  x: 0,
  y: 0,
  z: 0,
//^ Object literal may only specify known properties, and 'z' does not exist in type 'Position'.(2353)
}
```

### Optional Property Type

```ts
type Position = { x: number; y?: number; };

declare const position: Position;

position.x;
      // ^? (property) x: number
position.y;
      // ^? (property) y?: number | undefined
```

```ts
position.x + position.y
//           ^^^^^^^^^^ 'position.y' is possibly 'undefined'.(18048)
```

### Default Value

```ts
const { x, y = 0 } = position;
   
   x;
// ^? const x: number

   y;
// ^? const y: number
```

## Property Modifiers - Readonly 

### Syntax

```ts
type Position = { readonly x: number; readonly y: number; };

interface Position {
  readonly x: number;
  readonly y: number;
}
```

### Type Checks

```ts
type Position = { readonly x: number; readonly y: number; };

declare const position: Position;

position.x = 0;
      // ^ Cannot assign to 'x' because it is a read-only property.(2540)
position.y = 0;
      // ^ Cannot assign to 'y' because it is a read-only property.(2540)
```

```ts
position.x = 0;
      // ^? (property) x: any
position.y = 0;
      // ^? (property) y: any
```

### Nested

```ts
type Rectangle = {
  readonly position: { x: number; y: number; };
}

declare const rect: Rectangle;

rect.position.x = 0;
rect.position.y = 0;

rect.position = {
  // ^^^^^^^^ Cannot assign to 'position' because it is a read-only property.(2540)
  x: 0,
  y: 0,
}
```

### Read Write Separation

```ts
type Position = { x: number; y: number; };
type ReadonlyPosition = { readonly x: number; readonly y: number; };

const position: Position = { x: 0, y: 0 };

const readonlyPosition: ReadonlyPosition = position;

position.x = 1;
position.y = 1;

readonlyPosition.x = 1;
              // ^ Cannot assign to 'x' because it is a read-only property.(2540)
readonlyPosition.y = 1;
              // ^ Cannot assign to 'y' because it is a read-only property.(2540)
```

### Readonly

```ts
type Position = { x: number; y: number; };

type ReadonlyPosition = Readonly<{ x: number; y: number; }>;
```

### `const`

```ts
const position = { x: 0, y: 0 } as const;
   // ^? const position: { readonly x: 0; readonly y: 0; }
```

## Property Modifiers - Index Signature

### Syntax

```ts
type Mapping = {
  [index: string]: string;
}

interface Mapping {
  [index: string]: string;
}

const mapping: { [index: string]: string } = {};
```

Only some types are allowed for index signature properties: 
string, number, symbol, template string patterns, and union types consisting only of these.

### Empty Object

```ts
type Mapping = {
  [index: string]: string;
}

const mapping1 = {};
mapping1.x = 'hello';
      // ^ Property 'x' does not exist on type '{}'.(2339)
mapping1.y = 'world';
      // ^ Property 'y' does not exist on type '{}'.(2339)

const mapping2: { [index: string]: string } = {}
mapping2.x = 'hello';
mapping2.y = 'world';
```

### Enforce Properties

```ts
type Mapping = {
  [index: string]: string;
  name: number;
//^^^^ Property 'name' of type 'number' is not assignable to 'string' index type 'string'.(2411)
}
```

```ts
type Mapping = {
  [index: string]: string | number;
  name: number;
}
```

### Readonly Index Signature

```ts
type Mapping = {
  readonly [index: string]: string;
}

const mapping: Mapping = {};

   mapping.x = '1'
// ^^^^^^^^^ Index signature in type 'Mapping' only permits reading.(2542)
```

### Array

```ts
type Indexable = {
  [index: number]: string;
}

const array: Indexable = [
  'hello'
];

array[0]; // 'hello'

array[1] = 'world';
```