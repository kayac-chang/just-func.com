

## 是因為 JavaScript 是沒有型別的語言嗎？

JavaScript 是有型別的，
應該說，任何高階程式語言都有型別，
不同的型別可以用來區分資料的用途跟行為，
像是 `string` 跟 `number` 是兩種不同的型別，
`string` 用來表示純文字，`number` 用來表示數字，
他們針對同樣的動作 (operation) 產生的對應行為也不同。

例如.

```js
console.log(1 + 1);  // => 2
console.log('1' + '1'); // => '11'
```

再來對照 Java。

```java
System.out.println(1 + 1); // => 2
System.out.println("1" + "1"); // => "11"
```

兩邊對於數值 (value) 與其型別的差異並不大。

接下來，我們來看真正的差異所在。
以下，我們先宣告 (declare) 變量 `a`，但不初始化其變量 (initialize)。

```js
let a;
a = 1;
a = '1';
```

以上範例可以看出，
變量 `a` 先被賦予了 `number` 型別，
之後又被換成了 `string` 型別。

```java
String a;
a = 1; // Incompatible types: int cannot be converted to java.lang.String
a = "1";
```

對照組可以看到，
變量 `a` 一開始就被 **限制** 了可以賦予的型別，
所以當之後想要賦予 `a` `number` 型別時，
編譯器 (Compiler) 會拋出錯誤來 **阻止開發者撰寫不合理的程式碼**。

另一個例子，用 Java 的 `var` 來推斷 (inference) `a` 的型別，
```java
var a; // Error: Cannot infer type for local variable a   (cannot use 'var' on variable without initializer)
a = "1";
```

即便是 `var`，Java 還是要求在宣告的當下就要提供型別來 **限制**。

再來讓我們看看宣告當下就初始化數值 (initialize) 的範例。

```
var a = "1";
a = 1; // Incompatible types: int cannot be converted to java.lang.String
```

在上面的範例中，變量 `a` 宣告的當下就被賦予了數值以及其數值的型別 `String`，
所以當之後想要賦予 `a` `number` 型別時，編譯器 (Compiler) 會拋出錯誤。

下面是 JavaScript 的範例，  

```js
let a = '1';
a = 1;
```

我們可以看到 JavaScript 並沒有阻止我們賦予變量 `a` 不同的型別。

以上我歸納出真正的差異並非是 **沒有型別**，  
而是 **宣告的變量沒有型別限制**。

## 變量沒有型別的限制有什麼問題嗎？

坦白說我個人的結論是 沒什麼問題。

不只是 JavaScript 很多的語言都是這個特性，像是 Python, Ruby, PHP, Elixir。  
對於熟悉語言特性的開發者來說，  
他們照樣可以開發出能力強大的應用程式，  
這世界上成千上百的大小公司使用這類語言來開發他們的服務，  
根本不成問題。

所以我認為要關注命題的不是 變量沒有型別的限制 會有什麼問題，  
而是 加上變量的型別限制 有什麼好處。

## 加上變量的型別限制 有什麼好處？

我認為這麼做的最大的受益方是開發人員，

1. 透過編譯器 (Compiler) 來預防開發者犯低級錯誤

它可以防止像是 打錯字，或是拋錯資料型別等低級錯誤。

我是一個常犯低級錯誤且個性很散仙的工程師，  
常常看動畫漫畫到凌晨，導致隔天腦子不清楚。

透過程式來防止我犯蠢，讓我即便在狀況不好的情況，  
撰寫的程式依然可以維持一定的品質。

2. 異動時的保障

程式異動必然伴隨著出錯的風險。  
程式異動包含 增加功能，除錯，重構。

無論是小型或是大型的異動，  
我們都要保證應用程式的運作符合預期。

但我們很難每次做異動都用人力去逐一檢查，  
當檢查的範圍越大，它需要的人力跟時間都會越來越大，  
更何況是人類就會偷懶。

這就是為什麼我們需要設計自動化檢查來減少人工的成本，  
而自動化檢查也包含了 靜態程式分析。  
透過 靜態程式分析 可以排除一些錯誤，而不需要實際運行程式，  
靜態程式分析 其中也包含 靜態型別檢查。

多項檢查通過會提供產品方跟用戶雙方足夠的信心，  
就如同食物需要過安全標章一樣的道理。

3. 程式內的資料標準化

逐漸擴大並逐漸複雜化是大多應用程式需要面對的過程。  
(這邊用 **大多** 是因為 不一定應用程式會經歷擴大跟複雜化。)

當應用程式複雜到一個程度，  
我們是很難單從變量本身看出它到底會是什麼類型的資料，  
更何況變量可能會在中途被賦予非預期的資料型別。



當我們正在寫 TypeScript 時，其實是同時在寫兩種語言，
一種語言用來定義實際數值，另一種語言則用來定義型別，
你可以想成

```math
TypeScript = JavaScript + Type Language
```

用來定義實際數值的語言 (JavaScript)，
是實際會在運行階段 (Runtime) 運作的語言，
是實際用來幫助用戶解決問題的工具。

用來定義型別的語言，則只會在編譯階段 (Compile Time) 之前運作，
並會在 Compile 結束之後移除型別相關的資訊，
不同於前者，它主要是用來幫助開發者開發的工具。

> 註.



TypeScript 的型別系統不是傳統物件導向的類別 (class)，
而是集合論的集合 (set)。
